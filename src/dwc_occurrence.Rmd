---
title: "Darwin Core mapping for occurrence dataset"
author: Peter Desmet
output:
  md_document:
    variant: markdown_github
    pandoc_args: ["--atx-headers"]
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../reports/",sub(".Rmd", ".md", basename(input_file))))})
---

# `r rmarkdown::metadata$title`

By: `r rmarkdown::metadata$author`

Date: `r Sys.Date()`

```{r configure_knitr, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Setup

Set locale (so we use UTF-8 character encoding):

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse) # For data transformations

# None core tidyverse packages:
library(magrittr)  # For %<>% pipes
library(stringr)   # For string manipulation

# Other packages
library(janitor)   # For cleaning input data
library(knitr)     # For nicer (kable) tables
```

Set file paths (all paths should be relative to this script):

```{r}
raw_data_file = "../data/input/denormalized_observations_50000.csv"
dwc_occurrence_file = "../data/output/dwc_occurrence/occurrence.csv"
```

## Read data

Read the source data:

```{r}
raw_data <- read.csv(raw_data_file, fileEncoding = "UTF-8")
```

Clean data somewhat:

```{r}
raw_data %>%
  # Remove empty rows
  remove_empty_rows() %>%
  # Have sensible (lowercase) column names
  clean_names() -> raw_data
```

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

Save those column names as a list (makes it easier to remove them all later):

```{r}
raw_colnames <- colnames(raw_data)
```

List all fields:

```{r}
raw_colnames
```

Number of records:

```{r}
count(raw_data)
```

Preview data:

```{r}
kable(head(raw_data))
```

## Create occurrence core

### Pre-processing

```{r}
occurrence <- raw_data
```

Sort by transmitter and date:

```{r}
occurrence %<>% arrange(raw_transmitter, raw_datetime)
```

### Term mapping

Map the source data to [Darwin Core Occurrence](http://rs.gbif.org/core/dwc_occurrence_2015-07-02.xml) (but in the classic Darwin Core order):

#### type

```{r}
occurrence %<>% mutate(type = "Event")
```

#### language

```{r}
occurrence %<>% mutate(language = "en")
```

#### license

```{r}
occurrence %<>% mutate(license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

#### rightsHolder

Organization who owns the tag (receiver network can be used by all):

```{r}
occurrence %<>% mutate(rightsHolder = recode(as.character(raw_tag_owner_organization),
  "EVINBO"                       = "INBO",
  "INST. VOOR NATUUR-&"          = "INBO",
  "INST. VOOR NATUUR-EN"         = "INBO",
  "INST. VORR NATUUR-&"          = "INBO",
  "LIFEWATCH-INBO"               = "INBO",
  "VLAAMS INSTITUUT VOOR DE ZEE" = "VLIZ",
  .default = "",
  .missing = ""
))

# TODO: was supposed to be animal project organization
```

Show mapped values:

```{r}
occurrence %>% 
  select(raw_tag_owner_organization, rightsHolder) %>%
  group_by(raw_tag_owner_organization, rightsHolder) %>%
  summarize(records = n()) %>%
  arrange(raw_tag_owner_organization) %>%
  kable()
```

#### accessRights

```{r}
occurrence %<>% mutate(accessRights = "http://www.inbo.be/en/norms-for-data-use")
```

#### datasetID

```{r}
occurrence %<>% mutate(datasetID = "") # TODO: add DOI
```

#### institutionCode

```{r}
occurrence %<>% mutate(institutionCode = rightsHolder)
```

#### datasetName

```{r}
occurrence %<>% mutate(datasetName = "Acoustic telemetry tracking data of fish in the Scheldt river basin and the Belgian Part of the North Sea (BPNS)")
```

#### basisOfRecord

```{r}
occurrence %<>% mutate(basisOfRecord = "MachineObservation")
```

#### informationWithheld

```{r}
occurrence %<>% mutate(informationWithheld = "see metadata")
```

#### dynamicProperties

```{r}
occurrence %<>% mutate(dynamicProperties = paste0(
  "{\"transmitter\":\"", raw_transmitter, "\", ",
  "\"receiver\":\"", raw_receiver, "\"}"
))
```

#### occurrenceID

```{r}
occurrence %<>% mutate(occurrenceID = paste("otn", "lifewatch", raw_id_pk, sep = ":"))
```

Check for duplicate `occurrenceID`s (should be 0):

```{r}
anyDuplicated(occurrence$occurrenceID)
```

#### sex

```{r}
occurrence %<>% mutate(sex = recode(as.character(raw_sex),
  "F" = "female",
  "M" = "male",
  .default = "",
  .missing = ""
))
```

Show mapped values:

```{r}
occurrence %>%
  select(raw_sex, sex) %>%
  group_by(raw_sex, sex) %>%
  summarize(records = n()) %>%
  arrange(raw_sex) %>%
  kable()
```

#### lifeStage

```{r eval = FALSE}
occurrence %<>% mutate(recode(as.character(raw_life_stage),
  "FV" = "?",
  "FIII" = "?",
  .default = "",
  .missing = ""
))

# TODO: complete this information... or add it to individuals table.
```

#### organismID

```{r}
occurrence %<>% mutate(organismID = raw_animal_id) # TODO: This one is often NA
# Transmitter would have been nicer
```

#### eventID

```{r}
# TODO: could potentially be deployment (more a parentEventID).
```

#### eventDate

`datetime` assumed to be UTC. For 3D analyses milliseconds will be required, but these won't be available in the source data until VRL imports are supported.

```{r}
occurrence %<>% mutate(eventDate = format(as.POSIXct(raw_datetime), format = "%Y-%m-%dT%H:%M:%SZ")) # TODO: verify if UTC
```

#### eventTime

```{r}
# TODO: could be used to indicate local time
```

#### samplingProtocol

```{r}
# TODO: refer to DOI of methodology paper? Can some information be derived from source data?
# receiver_type: acoustic_telemetry, SVN, active
# receiver_model_number: VR2W, NA, 122325
# capture_method: NA, LINE FISHING, FYKE NETS
# 
```

#### locationID

The `station_name` is a fixed code for that deployment location. The `receiver` code is not adequate, as a receiver can be moved from one location to another.

```{r}
occurrence %<>% mutate(locationID = raw_deployment_station_name)
# TODO: Should it be station_name (120095, S-3-1) or deployment_station_name (ma-2, s-3)?
```

#### waterBody

```{r}
# TODO: Could be useful to filter? Either based on marine regions gazetteer from coordinates or based on a field in the source data?
```

#### countryCode

```{r}
# TODO: Can be useful to filter and could be derived from coordinates, but trickier for records at sea?
```

#### locality

Although there is location information available in the `deployment_location` fields, it not very useful to share these raw Dutch location names:

```{r}
occurrence %>%
  select(contains("deployment_location")) %>%
  unique() %>%
  head() %>%
  kable()
```

#### minimumDepthInMeters

Pressure tags collect depth information, but that won't be available in the source data until VRL imports are supported.

#### decimalLatitude

There are several columns with coordinates information (listing percentage of `NA`s):

```{r}
occurrence %>%
  select(contains("_lat"), contains("_long")) %>% # Looking for _lat(itude) in column name
  select(order(colnames(.))) %>% # Order alphabetically
  sapply(function(x) 100*mean(is.na(x))) %>%
  kable()
```

Of those the **deployment** coordinates of the receiver are the closest approximation of the position of the fish and always populated (no `NA`s in table above):

```{r}
occurrence %<>% mutate(decimalLatitude = sprintf("%.7f", round(raw_deployment_deploy_lat, digits = 7)))
```

#### decimalLongitude

```{r}
occurrence %<>% mutate(decimalLongitude = sprintf("%.7f", round(raw_deployment_deploy_long, digits = 7)))
```

#### geodeticDatum

```{r}
occurrence %<>% mutate(geodeticDatum = "WGS84")
```

#### coordinateUncertaintyInMeters

```{r}
# Depends on area: sea / Westerscheldt: 200m on average, 500m extreme, while Albertkanaal: 2km
# TODO: on which field should this be based?
# network_project_code?
# animal_project_code?
# receiver?
```

#### georeferenceSources

```{r}
occurrence %<>% mutate(georeferenceSources = "GPS") # TODO: not always GPS, maybe drop term
```

#### georeferenceVerificationStatus

```{r}
occurrence %<>% mutate(georeferenceVerificationStatus = "unverified") # TODO: maybe drop term
```

#### scientificName

Show unique values:

```{r}
occurrence %>%
  select(raw_scientific_name) %>%
  group_by(raw_scientific_name) %>%
  summarize(records = n()) %>%
  kable()
```

Map scientific name:

```{r}
occurrence %<>% mutate(scientificName = raw_scientific_name)
```

#### kingdom

```{r}
occurrence %<>% mutate(kingdom = "animalia")
```

Some other higher classication terms could be populated, but with the limited number of species it's not really useful as extra filters.

#### taxonRank

```{r}
occurrence %<>% mutate(taxonRank = "species") # TODO: all species?
```

#### vernacularName

```{r}
# occurrence %<>% mutate(vernacularName = raw_common_name) # TODO: ever populated?
```

### Post-processing

Filter out records with `Sync tag` as scientific name:

```{r}
occurrence %<>% filter(raw_scientific_name != "Sync tag")
count(occurrence)
```

Filter out records under a moratorium:

```{r}
occurrence %<>% filter(raw_animal_moratorium == 1) # TODO: or was it network_moratorium?
count(occurrence)
```

Remove the original columns:

```{r}
occurrence %<>% select(-one_of(raw_colnames))
```

Preview data:

```{r}
kable(head(occurrence))
```

Save to CSV:

```{r}
write.csv(occurrence, file = dwc_occurrence_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```
